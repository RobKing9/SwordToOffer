# [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

## 题目

一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

```golang
示例 1：

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
示例 2：

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```


限制：

- 2 <= nums.length <= 10000.0.

## 思路

方法：位运算

主要思路：首先我们需要知道异或和与

- 异或：两个数异或，如果相同的话，结果为0,。比如 101 ^ 101 = 000, 101 ^ 001 = 100
- 与：两个位都为1的时候才为1，其他情况都为0。比如 101 & 100 = 100
- 循环左移运算：m<<=1，一开始为0001-->0010-->0100-->1000

这一题之所以可以运用这种方法，是因为重复的都是两个，只要异或都为0

1. 这样数组所有数组异或最后只剩下两个数的异或，这是第一步。
2. 接下来我们要做的就是找出这两个数，我们可以知道这两个数一定有某一位不相同（0， 1），这一位异或的结果肯定为1，我们用一个数来找出这一位并且标记出来，这里使用的是循环左移运算，每一次都会往高位变成1，当与的结果不为0的时候意味着我们找到这个1的位置了
3. 之后我们将数组所有的数字与这个数进行与，判断是否为0，首先很明确的知道，肯定有一个是会为0的，并且是两个不同数字之间的某一个，因为一个数的这一位为0，而m的高位都为0，所以这两个数与的结果一定为0，这样就把两个不同的数分开了，最后返回结果即可。

## 代码

```golang
func singleNumbers(nums []int) []int {
    //位运算
    //只有两个完全一样的数异或（^）才会等于0
    //与（&）两个位都为1，结果才为1
    //首先找到 两个不一样数 的异或
    n := 0
    for _, v := range nums {
        n ^= v
    }
    //然后通过 循环左运算 找到 最低位不相同的值 
    //用 m 记录
    m := 1
    // m := n & (-n)
    // for m&n == 0 {
    //     m >>= 1
    // }
    //时间最快的一种方式
    for ; m != 0 && n&m == 0; m <<= 1 {
	}
    x, y := 0, 0
    //就说明 m 记录的这一位 两个不同的数 取与 必然会导致两种情况，一个为0，一个不为0
    for _, v := range nums {
        if v&m==0 {
            x ^= v
        }else {
            y ^= v
        }
    }
    return []int{x, y}
}
```

时间复杂度：O(n)

空间复杂度：O(1)
