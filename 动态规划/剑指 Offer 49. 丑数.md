# [剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)

## 题目

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

```
示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

说明:  

- 1 是丑数。
- n 不超过1690。



## 思路

方法：动态规划

主要思路：我们知道每个丑数都是由之前的序列的每个值 *2 *3 *5 得到的，但是这样的话会有重复，我们需要得到一个不重复并且按照从小到大的顺序排列的，所以我们可以建立三个索引来控制他们的速度，每一次取最小的那个值，并且这个数往后移动一位，每一次循环更新值，以保证下一个还没有建立乘积的数。

细节：因为可能两个索引出现相同的值，那么这时候应该都要往后移动一位。

## 代码

```golang
func nthUglyNumber(n int) int {
    //动态规划
    //思路：我们知道每个丑数都是由之前的序列的每个值 *2 *3 *5 得到的，但是这样的话会有重复，我们需要得到一个不重复并且按照从小到大的顺序排列的，所以我们可以建立索引来控制他们的速度，每一次取最小的那个值
    dp := make([]int, n)
    //初始化
    dp[0] = 1
    //记录 索引 到哪里了
    a, b, c := 0, 0, 0
    //遍历到n
    for i:=1; i<n; i++ {
        n2, n3, n5 := dp[a]*2, dp[b]*3, dp[c]*5
        dp[i] = min(min(n2, n3), n5)
        //如果是因为这个数乘积得到的 那么就要移动到下一位
        //如果有两个乘积一样得到的 那么都要移动
        if n2 == dp[i] {
            a++
        }
        if n3 == dp[i] {
            b++
        }
        if n5 == dp[i] {
            c++
        }
    }
    return dp[n-1]
}

func min(x, y int) int {
    if x<y {
        return x
    }
    return y
}
```

